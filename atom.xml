<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>杰哥</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-09-06T12:04:46.652Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>decode-life</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>带你入门java8新特性</title>
    <link href="http://yoursite.com/2018/09/06/%E5%B8%A6%E4%BD%A0%E5%85%A5%E9%97%A8java8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>http://yoursite.com/2018/09/06/带你入门java8新特性/</id>
    <published>2018-09-06T12:02:12.000Z</published>
    <updated>2018-09-06T12:04:46.652Z</updated>
    
    <content type="html"><![CDATA[<h1 id="它是什么"><a href="#它是什么" class="headerlink" title="它是什么"></a>它是什么</h1><h3 id="术语定义"><a href="#术语定义" class="headerlink" title="术语定义"></a>术语定义</h3><blockquote><p><strong>百度百科定义：</strong> “Lambda 表达式”(lambda expression)是一个==匿名函数==，Lambda表达式基于数学中的λ演算得名，直接对应于其中的lambda抽象(lambda abstraction)，是一个匿名函数，即没有函数名的函数。Lambda表达式可以表示闭包</p></blockquote><h1 id="java中的实现方式"><a href="#java中的实现方式" class="headerlink" title="java中的实现方式"></a>java中的实现方式</h1><blockquote><p>lambda表达式的目标类型是“函数接口（functional interface）”，这是Java8新引入的概念。<strong>它的定义是：</strong> 一个接口，如果只有一个显式声明的抽象方法，那么它就是一个函数接口。一般用@FunctionalInterface标注出来（也可以不标）。</p></blockquote><h2 id="Lambda表达式-vs-匿名类"><a href="#Lambda表达式-vs-匿名类" class="headerlink" title="Lambda表达式 vs 匿名类"></a>Lambda表达式 vs 匿名类</h2><blockquote><p>既然lambda表达式即将正式取代Java代码中的匿名内部类，那么有必要对二者做一个比较分析。一个关键的不同点就是关键字 this。匿名类的 this 关键字指向匿名类，而lambda表达式的 this 关键字指向包围lambda表达式的类。另一个不同点是二者的编译方式。Java编译器将lambda表达式编译成类的私有方法。使用了Java 7的 invokedynamic 字节码指令来动态绑定这个方法。</p></blockquote><h1 id="同类技术："><a href="#同类技术：" class="headerlink" title="同类技术："></a>同类技术：</h1><p>Python， Ruby， Lua</p><h1 id="为什么会出现"><a href="#为什么会出现" class="headerlink" title="为什么会出现"></a>为什么会出现</h1><ol><li>简化代码</li><li>有些运算中的变量甚至是算法函数过程其实不是必须要定义出来，只是中间过渡一下</li><li>对之后stream接口集合的便利操作提供基础支持，lambda 表达式能简化集合上数据的多线程或者多核的处理，提供更快的集合处理速度</li></ol><h1 id="实例走一波"><a href="#实例走一波" class="headerlink" title="实例走一波"></a>实例走一波</h1><h3 id="1-线程创建"><a href="#1-线程创建" class="headerlink" title="1. 线程创建"></a>1. 线程创建</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//lambda之前</span><br><span class="line">new Thread(new Runnable()&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run()&#123;</span><br><span class="line">        System.out.println(&quot;我在努力跑&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line">//lambda之后</span><br><span class="line">new Thread(() -&gt; System.out.println(&quot;我起跑更快&quot;)).start();</span><br></pre></td></tr></table></figure><h3 id="2-Predicate-条件函数式接口，并且可以多个条件过滤"><a href="#2-Predicate-条件函数式接口，并且可以多个条件过滤" class="headerlink" title="2. Predicate 条件函数式接口，并且可以多个条件过滤"></a>2. Predicate 条件函数式接口，并且可以多个条件过滤</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Predicate startsWithJ = (n) -&gt; n.startsWith(&quot;J&quot;);</span><br><span class="line"></span><br><span class="line">Predicate fourLetterLong = (n) -&gt; n.length() ==4;</span><br><span class="line"></span><br><span class="line">names.stream().filter(startsWithJ.and(fourLetterLong))</span><br><span class="line"></span><br><span class="line">.forEach((n) -&gt; System.out.print(&quot;nName, which starts with &apos;J&apos; and four letter long is : &quot;+ n));</span><br></pre></td></tr></table></figure><h3 id="3-stream-接口"><a href="#3-stream-接口" class="headerlink" title="3. stream 接口"></a>3. stream 接口</h3><ul><li><p><strong>3.1 map 操作</strong></p><p>  本例介绍最广为人知的函数式编程概念map。它允许你将对象进行转换。例如在本例中，我们将 costBeforeTax 列表的每个元素转换成为税后的值。我们将 x -&gt; x*x lambda表达式传到 map() 方法，后者将其应用到流中的每一个元素。然后用 forEach() 将列表元素打印出来。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 不使用lambda表达式为每个订单加上12%的税</span><br><span class="line">List costBeforeTax = Arrays.asList(100, 200, 300, 400, 500);</span><br><span class="line">for (Integer cost : costBeforeTax) &#123;</span><br><span class="line">    double price = cost + .12*cost;</span><br><span class="line">    System.out.println(price);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// 使用lambda表达式</span><br><span class="line">List costBeforeTax = Arrays.asList(100, 200, 300, 400, 500);</span><br><span class="line">costBeforeTax.stream().map((cost) -&gt; cost + .12*cost).forEach(System.out::println);</span><br></pre></td></tr></table></figure><ul><li><p><strong>3.2 reduce操作</strong></p><p>  在上个例子中，可以看到map将集合类（例如列表）元素进行转换的。还有一个 reduce() 函数可以将所有值合并成一个。Map和Reduce操作是函数式编程的核心操作，因为其功能，reduce 又被称为折叠操作。另外，reduce 并不是一个新的操作，你有可能已经在使用它。SQL中类似 sum()、avg() 或者 count() 的聚集函数，实际上就是 reduce 操作，因为它们接收多个值并返回一个值。流API定义的 reduceh() 函数可以接受lambda表达式，并对所有值进行合并。IntStream这样的类有类似 average()、count()、sum() 的内建方法来做 reduce 操作，也有mapToLong()、mapToDouble() 方法来做转换。这并不会限制你，你可以用内建方法，也可以自己定义。在这个Java 8的Map Reduce示例里，我们首先对所有价格应用 12% 的VAT，然后用 reduce() 方法计算总和。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 为每个订单加上12%的税</span><br><span class="line">// 老方法：</span><br><span class="line">List costBeforeTax = Arrays.asList(100, 200, 300, 400, 500);</span><br><span class="line">double total = 0;</span><br><span class="line">for (Integer cost : costBeforeTax) &#123;</span><br><span class="line">    double price = cost + .12*cost;</span><br><span class="line">    total = total + price;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;Total : &quot; + total);</span><br><span class="line"> </span><br><span class="line">// 新方法：</span><br><span class="line">List costBeforeTax = Arrays.asList(100, 200, 300, 400, 500);</span><br><span class="line">double bill = costBeforeTax.stream().map((cost) -&gt; cost + .12*cost).reduce((sum, cost) -&gt; sum + cost).get();</span><br><span class="line">System.out.println(&quot;Total : &quot; + bill);</span><br></pre></td></tr></table></figure><h4 id="4-匿名方法改进之路（Lambda-和方法引用实战）"><a href="#4-匿名方法改进之路（Lambda-和方法引用实战）" class="headerlink" title="4. 匿名方法改进之路（Lambda 和方法引用实战）"></a>4. 匿名方法改进之路（Lambda 和方法引用实战）</h4><ul><li><p>第1种：传递代码</p><p>  Java 8的API已经为你提供了一个 List 可用的 sort 方法，那么如何把排序策略传递给 sort 方法呢？sort方法的签名是这样的：</p><p>  void sort(Comparator&lt;? super E&gt; c)<br>  它需要一个 Comparator 对象来比较两个Apple！这就是在Java中传递策略的方式：它们必须包裹在一个对象里。我们说 sort 的行为被参数化了：传递给它的排序策略不同，其行为也会 不同。<br>  第一个解决方案可以是这样的：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class AppleComparator implements Comparator&lt;Apple&gt; &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public int compare(Apple o1, Apple o2) &#123;</span><br><span class="line">            return o1.getWeight().compareTo(o2.getWeight());</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">apples.sort(new AppleComparator())</span><br></pre></td></tr></table></figure></li><li><p>第2步：使用匿名类</p><p>  可以使用匿名类来改进方案，而不是实现一个 Comparator 却只实例化一次：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">apples.sort(new Comparator&lt;Apple&gt;() &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public int compare(Apple o1, Apple o2) &#123;</span><br><span class="line">      return o1.getWeight().compareTo(o2.getWeight());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>第3步：使用 Lambda 表达式</p><p>  接下来使用 Lambda 表达式来改进方案：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apples.sort((Apple a1,Apple a2) -&gt; a1.getWeight().compareTo(a2.getWeight()));</span><br></pre></td></tr></table></figure><p>  Comparator 具有一个叫作 comparing 的静态辅助方法，它可以接受一个 Function 来提取 Comparable 键值，并生成一个 Comparator 对象，它可以像下面这样用（注意你现在传递的Lambda只有一 个参数：Lambda说明了如何从苹果中提取需要比较的键值）：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apples.sort(Comparator.comparing(((Apple apple) -&gt; apple.getWeight())));</span><br></pre></td></tr></table></figure></li><li><p>第4步：使用方法引用</p><p>  方法引用就是替代那些转发参数的 Lambda 表达式的语法糖。可以用方法引 用改进方案如下：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apples.sort(Comparator.comparing(Apple::getWeight));</span><br></pre></td></tr></table></figure></li></ul><h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>如上所述，lambda表达式等新特性给我们编程实现带来了新的支持可能，更加方便的计算（尤其是集合）</p><ul><li><p>Lambda表达式可以理解为一种匿名函数：它没有名称，但有参数列表、函数主体、返回 类型，可能还有一个可以抛出的异常的列表。</p></li><li><p>Lambda表达式让你可以简洁地传递代码。</p></li><li><p>函数式接口就是仅仅声明了一个抽象方法的接口。</p></li><li><p>只有在接受函数式接口的地方才可以使用Lambda表达式。</p></li><li><p>Lambda表达式允许你直接内联，为函数式接口的抽象方法提供实现，并且将整个表达式作为函数式接口的一个实例。</p></li><li><p>Java 8自带一些常用的函数式接口，放在java.util.function包里，包括Predicate<t>、Function&lt;T,R&gt;、Supplier<t>、Consumer<t>和BinaryOperator<t>。</t></t></t></t></p></li><li><p>为了避免装箱操作，对Predicate<t>和Function&lt;T, R&gt;等通用函数式接口的原始类型特化：IntPredicate、IntToLongFunction等。</t></p></li><li><p>环绕执行模式（即在方法所必需的代码中间，你需要执行点儿什么操作，比如资源分配 和清理）可以配合 Lambda 提高灵活性和可重用性。</p></li><li><p>Lambda 表达式所需要代表的类型称为目标类型。</p></li><li><p>方法引用让你重复使用现有的方法实现并直接传递它们。</p></li><li><p>Comparator、Predicate和Function等函数式接口都有几个可以用来结合 Lambda 表达式的默认方法。</p></li></ul><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ol><li><a href="http://www.jianshu.com/p/f569c090ec15" target="_blank" rel="noopener">理解java8 lambda http://www.jianshu.com/p/f569c090ec15</a></li><li><a href="http://www.importnew.com/16436.html" target="_blank" rel="noopener">Java8 lambda表达式10个示例</a></li><li><a href="http://www.jianshu.com/p/4b6a875694f0" target="_blank" rel="noopener">java8 新特性</a></li><li><a href="http://www.jianshu.com/p/b0ccbea7213e" target="_blank" rel="noopener">深入理解Java 8 Lambda表达式（Oracle官方文档版）</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;它是什么&quot;&gt;&lt;a href=&quot;#它是什么&quot; class=&quot;headerlink&quot; title=&quot;它是什么&quot;&gt;&lt;/a&gt;它是什么&lt;/h1&gt;&lt;h3 id=&quot;术语定义&quot;&gt;&lt;a href=&quot;#术语定义&quot; class=&quot;headerlink&quot; title=&quot;术语定义&quot;&gt;&lt;/a
      
    
    </summary>
    
    
      <category term="java8 lambda" scheme="http://yoursite.com/tags/java8-lambda/"/>
    
  </entry>
  
  <entry>
    <title>jdk安徽及环境配置一篇搞定</title>
    <link href="http://yoursite.com/2018/09/05/jdk%E5%AE%89%E5%BE%BD%E5%8F%8A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E4%B8%80%E7%AF%87%E6%90%9E%E5%AE%9A/"/>
    <id>http://yoursite.com/2018/09/05/jdk安徽及环境配置一篇搞定/</id>
    <published>2018-09-05T09:41:39.000Z</published>
    <updated>2018-09-06T01:34:54.473Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者 <a href="https://www.zhihu.com/people/decode-life/activities" target="_blank" rel="noopener">Decodelife</a> 转载请注明出处</p></blockquote><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><blockquote><p>鉴于广大Java爱好者或初学者甚至老手，在面临一个新的开发环境是，总是要搭建一套初始工作环境，配置环境变量，有些时候还得是不是查阅下教程，特此整理了一份各个环境下的配置步骤，供大家查阅，<strong>以后大家环境变量一篇就够了</strong>，如果问题请指正</p></blockquote><h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><ol><li><p><strong>下载jdk</strong></p><ul><li>首先我们需要下载java开发工具包JDK，下载地址：<a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/downloads/index.html</a>，点击如下下载按钮：<br><img src="https://upload-images.jianshu.io/upload_images/1762862-1668938a243be4ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li><li>在下载页面中你需要选择接受许可，并根据自己的系统选择对应的版本，本文以 Window 64位系统为例：<br> <img src="https://upload-images.jianshu.io/upload_images/1762862-8ceb3654ef8e9c2b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li><li><p>下载后JDK的安装根据提示进行，还有安装JDK的时候也会安装JRE，一并安装就可以了。</p><p>安装JDK，安装过程中可以自定义安装目录等信息，例如我们选择安装目录为 C:\Program Files (x86)\Java\jdk1.8.0_91。</p></li></ul><ol start="2"><li><p><strong>配置环境变量</strong></p><ul><li><p>安装完成后，右击”我的电脑”，点击”属性”，选择”高级系统设置”；<br><img src="https://upload-images.jianshu.io/upload_images/1762862-212fa4e378532202.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></li><li><p>选择”高级”选项卡，点击”环境变量”；<br><img src="https://upload-images.jianshu.io/upload_images/1762862-517a9f4c11f054db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></li><li><p>然后就会出现如下图所示的画面：<br><img src="https://upload-images.jianshu.io/upload_images/1762862-9929ceb9a65aea9b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></li><li><p>在”系统变量”中设置3项属性，JAVA_HOME,PATH,CLASSPATH(大小写无所谓),若已存在则点击”编辑”，不存在则点击”新建”。<br><em>变量设置参数如下</em><br>变量名：JAVA_HOME<br>变量值：C:\Program Files (x86)\Java\jdk1.8.0_91        // 要根据自己的实际路径配置<br>变量名：CLASSPATH<br>变量值：.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;         //记得前面有个”.”<br>变量名：Path<br>变量值：%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin;</p></li><li><p>JAVA_HOME 设置<br><img src="https://upload-images.jianshu.io/upload_images/1762862-503d5862199a0d00.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><img src="https://upload-images.jianshu.io/upload_images/1762862-05ad455ebb469487.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></li><li>PATH设置<br><img src="https://upload-images.jianshu.io/upload_images/1762862-99241e7744cd800f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><img src="https://upload-images.jianshu.io/upload_images/1762862-68e700b53a39b971.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><blockquote><p>注意：在 Windows10 中，Path 变量里是分条显示的，我们需要将 %JAVA_HOME%\bin;%JAVA_HOME%\jre\bin; 分开添加，否则无法识别：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%JAVA_HOME%\bin;</span><br><span class="line">%JAVA_HOME%\jre\bin;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p><img src="https://upload-images.jianshu.io/upload_images/1762862-5bbd3b7decbaed89.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></blockquote><ul><li>CLASSPATH 设置<br><img src="https://upload-images.jianshu.io/upload_images/1762862-5331fd0168412f51.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><blockquote><p><strong>注意</strong>：如果使用1.5以上版本的JDK，不用设置CLASSPATH环境变量，也可以正常编译和运行Java程序</p></blockquote></li></ul></li></ol></li><li><p><strong>测试JDK是否安装成功</strong></p><ul><li><p>“开始”-&gt;”运行”，键入”cmd”；</p></li><li><p>键入命令: java -version、java、javac 几个命令，出现以下信息，说明环境变量配置成功；<br><img src="https://upload-images.jianshu.io/upload_images/1762862-2e4f279991d5881a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></li></ul></li></ol><hr><h2 id="Linux（CentOS）MacOS类同"><a href="#Linux（CentOS）MacOS类同" class="headerlink" title="Linux（CentOS）MacOS类同"></a>Linux（CentOS）MacOS类同</h2><ol><li><p><strong>判断是否安装</strong></p><p> 首先，我们得判断机子上是不是安装了jdk，命令终端输入如下命令：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br><span class="line"># 输出如下</span><br><span class="line">java version &quot;1.7.0_45&quot;</span><br><span class="line">OpenJDK Runtime Environment (rhel-2.4.3.2.el6_4-i386 u45-b15)</span><br><span class="line">OpenJDK Server VM (build 24.45-b08, mixed mode)</span><br></pre></td></tr></table></figure><p> 这看起来好像我的机子中已经安装了jdk，但是当我使用javac时，会提示：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-bash: javac: command not found</span><br></pre></td></tr></table></figure><p> 这说明第一个java命令，不是安装的jdk中的java命令，而是在$PATH的所有路径下有一个可以执行的java文件，说明jdk还是没有正确安装。这个要特别注意。</p></li><li><p><strong>安装jdk</strong></p><ul><li>去<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a>中下载jdk的安装文件。由于我的Linux是32位的，因此我下载jdk-8u25-linux-i586.tar.gz文件。</li><li><p>新建/usr/java文件夹，将jdk-8u25-linux-i586.tar.gz放到该文件夹中，并将工作目录切换到/usr/java目录下。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd /usr</span><br><span class="line">## 创建目录（根据自己喜欢定义名称）</span><br><span class="line">mkdir java</span><br><span class="line">## 从官网下载压缩包</span><br><span class="line">wget http://download.oracle.com/otn-pub/java/jdk/8u181-b13/96a7b8442fe848ef90c96a2fad6ed6d1/jdk-8u181-linux-i586.tar.gz</span><br></pre></td></tr></table></figure></li><li><p>执行命令tar -zxvf jdk-8u25-linux-i586.gz 进行解压，解压后发现/usr/java多了一个jdk1.8.0_25文件夹。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> ## 解压文件</span><br><span class="line">tar -xzvf jdk-8u181-linux-i586.tar.gz</span><br></pre></td></tr></table></figure></li><li><p>通过以上步骤，jdk就已经全部安装完成了。下面，就是环境变量的配置。</p></li></ul></li><li><p><strong>配置环境变量</strong></p><ul><li>使用vim /etc/profile编辑profile文件</li><li><p>在/etc/profile底部加入如下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">JAVA_HOME=/usr/java/jdk1.8.0_25</span><br><span class="line">PATH=$JAVA_HOME/bin:$PATH</span><br><span class="line">CLASSPATH=$JAVA_HOME/jre/lib/ext:$JAVA_HOME/lib/tools.jar</span><br><span class="line">export PATH JAVA_HOME CLASSPATH</span><br></pre></td></tr></table></figure></li><li><p>以上，环境变量配置完成。</p><blockquote><ol><li>需要注意的是，PATH在配置的时候，一定要把\$JAVA_HOME/bin放在前面，不然使用java命令时，系统会找到以前的java，再不往下找了。这样java这个可执行文件运行的目录其实不在\$JAVA_HOME/bin下，而在其它目录下，会造成很大的问题。</li><li>还要注意，以前其它教程写的CLASSPATH=$JAVA_HOME/lib.tools.jar，不知道以前的版本是怎么样的，现在的版本是没有这样的jar包的。</li></ol></blockquote></li><li><p>最后使用如下命令让profile文件立即生效。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>命令测试</strong></p><ul><li>使用javac命令，不会出现command not found错误</li><li><p>使用java -version，出现版本为java version “1.8.0_25”<br><img src="https://upload-images.jianshu.io/upload_images/1762862-dc464a62d6f9a7bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></li><li><p>echo \$JAVA_HOME, echo \$CLASSPATH, echo $PATH，看看自己的配置是否都正确。</p></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;作者 &lt;a href=&quot;https://www.zhihu.com/people/decode-life/activities&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Decodelife&lt;/a&gt; 转载请注明出处&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="jdk" scheme="http://yoursite.com/tags/jdk/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2018/09/04/hello-world/"/>
    <id>http://yoursite.com/2018/09/04/hello-world/</id>
    <published>2018-09-04T11:06:06.753Z</published>
    <updated>2018-09-04T11:06:06.753Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
